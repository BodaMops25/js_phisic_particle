<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			width: 100vw;
			height: 100vh;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		button {
			position: absolute;
			top: 1%;
			left: 1%;
		}

		canvas {
			border: 1px solid #000;
		}
	</style>
</head>

<body>

	<button onclick="gravity = !gravity">Gravity</button>

	<canvas></canvas>

	<script>
		'use strict'

		const Phis_G = 6.67 * 1e-11

		const cnvs = document.querySelector('canvas'),
			//   cnvsW = 500,
			//   cnvsH = 250,
			  cnvsW = innerWidth * 0.9,
			  cnvsH = innerHeight * 0.9,
			  cnvsScl = 2,
			  ctx = cnvs.getContext('2d')

		const cnvsHW = cnvsW / 2,
			  cnvsHH = cnvsH / 2
			  
		cnvs.width = sN(cnvsW)
		cnvs.height = sN(cnvsH)

		cnvs.style.width = cnvsW + 'px'
		cnvs.style.height = cnvsH + 'px'

		function sN(...nums) {
			return nums.map(item => item * cnvsScl)
		}

		// GRAPHICS FUNCS

		function vector(x, y, endX, endY, color = '#000', weight = 1) {	
			const oldFillStyle = ctx.fillStyle,
				  oldStrokeStyle = ctx.strokeStyle,
				  oldLineWidth = ctx.LineWidth

			ctx.strokeStyle = color
			ctx.lineWidth = sN(weight)

			ctx.beginPath()
			ctx.moveTo(...sN(x, y))
			ctx.lineTo(...sN(x + endX, y + endY))
			ctx.stroke()

			ctx.beginPath()
			ctx.fillStyle = color		
			ctx.arc(...sN(x + endX, y + endY, weight + 1), 0, Math.PI * 2)
			ctx.fill()

			ctx.fillStyle = oldFillStyle
			ctx.strokeStyle = oldStrokeStyle
			ctx.lineWidth = oldLineWidth
		}

		// function toRad(deg) {
		// 	return deg * Math.PI / 180
		// }

		// function toDeg(rad) {
		// 	return rad * 180 / Math.PI
		// }

		// function lineToAngle(x, y, distance, angle) {

		// 	return [
		// 		Math.cos(toRad(angle)) * distance + x, 
		// 		Math.sin(toRad(angle)) * distance + y
		// 	]
		// }

		// function vector(x, y, distance, angle, color = '#000', weight = 1) {
		// 	const oldFillStyle = ctx.fillStyle,
		// 		  oldStrokeStyle = ctx.strokeStyle,
		// 		  oldLineWidth = ctx.LineWidth,
		// 		  lineToCoords = lineToAngle(x, y, distance, angle)

		// 	ctx.strokeStyle = color
		// 	ctx.lineWidth = sN(weight)

		// 	ctx.beginPath()
		// 	ctx.moveTo(x, y)
		// 	ctx.lineTo(...lineToCoords)
		// 	ctx.stroke()

		// 	ctx.beginPath()
		// 	ctx.fillStyle = color		
		// 	ctx.arc(...lineToCoords, sN(weight + 1), 0, Math.PI * 2)
		// 	ctx.fill()

		// 	ctx.fillStyle = oldFillStyle
		// 	ctx.strokeStyle = oldStrokeStyle
		// 	ctx.lineWidth = oldLineWidth
		// }

		// PARTICLES

		function Particle(x, y, mass = 1) {
			this.id = Particle.id
			this.x = x
			this.y = y
			this.mass = mass
			this.force = [0, 0]
			this.addForces = function(forcesArray) {
				this.force[0] += forcesArray.reduce((sum, [x, y]) => sum + x, 0)
				this.force[1] += forcesArray.reduce((sum, [x, y]) => sum + y, 0)
			}
			this.move = function() {

				// FORCES

				for(let particle of particles) {
					if(particle.id !== this.id) {
						const m1 = this.mass,
							  m2 = particle.mass,
							  r = Math.sqrt((this.x - particle.x)**2 + (this.y - particle.y)**2),
							  force = Phis_G * ((m1 * m2) / r**2) * 1e16


						// [this.x + 1; this.y] [particle.x - this.x; particle.y - this.y]
						// const [a1, a2, b1, b2] = [this.x + 1, this.y, particle.x - this.x, particle.y - this.y]
						// cosA = (a1*b1 + a2 * b2) / (Math.sqrt(a1**2 + a2**2) * Math.sqrt(b1**2 + b2**2))
						// 

						// this.addForces([[force, 0]])
					}
				}

				// BORDERS

				if(this.x + this.force[0] / this.mass / frameRate > cnvsW || 
				   this.x + this.force[0] / this.mass / frameRate < 0) this.force[0] = this.force[0] * -1
				if(this.y + this.force[1] / this.mass / frameRate > cnvsH || 
				   this.y + this.force[1] / this.mass / frameRate < 0) this.force[1] = this.force[1] * -1

				// ADD COORDS

				this.x += this.force[0] / this.mass / frameRate
				this.y += this.force[1] / this.mass /frameRate
			}
			this.display = function() {
				ctx.beginPath()
				ctx.fillStyle = '#000'
				ctx.arc(...sN(this.x, this.y, 5), 0, Math.PI * 2)
				ctx.fill()

				if(this.displayForcesVector) {
					vector(this.x, this.y, this.force[0] / 2, this.force[1] / 2, '#f5d142')
				}
			}
			this.displayForcesVector = false
			
			Particle.id++
		}

		Particle.id = 0

		const particles = [
			new Particle(cnvsHW - 100, cnvsHH - 50),
			new Particle(cnvsHW + 100, cnvsHH + 30)
		]

		// RENDER

		const frameRate = 1 // do not put more than 100, work slowly

		for(let particle of particles) {
			particle.displayForcesVector = true
		}

		let getUpdate = setInterval(() => {
			
			requestAnimationFrame(() => {
				ctx.clearRect(0, 0, ...sN(cnvsW, cnvsH))
				
				for(let particle of particles) {
					particle.move()
					particle.display()
				}
			})
		}, 1000 / frameRate)

		// clearInterval(getUpdate)

	</script>
</body>

</html>