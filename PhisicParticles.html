<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Phisic particles</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			width: 100vw;
			height: 100vh;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		canvas {
			border: 1px solid #000;
		}
	</style>
</head>
<body>
	
	<canvas></canvas>

	<script>
		'use strict'

		const Phis_G = 6.67 * 1e-11, scale = 1

		const cnvs = document.querySelector('canvas'),
			  ctx = cnvs.getContext('2d'),
			  cW = innerWidth * 0.9,
			  cH = innerHeight * 0.9,
			  cHW = cW / scale,
			  cHH = cH / scale
			  
		cnvs.width = cW * scale
		cnvs.height = cH * scale

		cnvs.style.width = cW + 'px'
		cnvs.style.height = cH + 'px'

		// FUNCTIONS

		function mod(num) {
			if(num < 0) return num * -1
			return num
		}
		
		function toRad(deg) {
			return deg * Math.PI / 180
		}
		
		function toDeg(rad) {
			return rad * 180 / Math.PI
		}

		function Pt(catet1, catet2) {
			return Math.sqrt(catet1**2 + catet2**2)
		}
		
		function lineToAngle(distance, angle, x = 0, y = 0) {			
			return [
				+(Math.cos(toRad(angle)) * distance + x).toFixed(2), 
				+(Math.sin(toRad(angle)) * distance + y).toFixed(2)
			]
		}

		function preAngleBetweenVectors(a1, a2, b1, b2) {
			let angle = toDeg(Math.acos(((a1 * b1) + (a2 * b2)) / (Pt(a1, a2) * Pt(b1, b2))))
			if(b2 < 0) angle = 360 - angle
			return +angle.toFixed(2)
		}
		
		function angleBetweenVectors(a1, a2, b1, b2) {
			let deltaAngle = preAngleBetweenVectors(1, 0, a1, a2),
				deltaAngle2 = preAngleBetweenVectors(1, 0, b1, b2),
				angle = preAngleBetweenVectors(a1, a2, b1, b2)

			if(deltaAngle > deltaAngle2) angle = 360 - angle
			return angle
		}
		
		function vector(x, y, endX, endY, color = '#000', Width = 1) {
			const oldFillStyle = ctx.fillStyle,
				  oldStrokeStyle = ctx.strokeStyle,
				  oldLineWidth = ctx.LineWidth

			ctx.strokeStyle = color
			ctx.lineWidth = Width

			ctx.beginPath()
			ctx.moveTo(x, y)
			ctx.lineTo(x + endX, y + endY)
			ctx.stroke()

			ctx.beginPath()
			ctx.fillStyle = color		
			ctx.arc(x + endX, y + endY, Width + 1, 0, Math.PI * 2)
			ctx.fill()

			ctx.fillStyle = oldFillStyle
			ctx.strokeStyle = oldStrokeStyle
			ctx.lineWidth = oldLineWidth
		}

		function circum(x, y, radius, color = '#000', Width = 1) {
			const oldStrokeStyle = ctx.strokeStyle,
				  oldLineWidth = ctx.LineWidth

			ctx.beginPath()
			ctx.strokeStyle = color
			ctx.lineWidth = Width
			ctx.arc(x, y, radius, 0, Math.PI * 2)
			ctx.stroke()

			ctx.strokeStyle = oldStrokeStyle
			ctx.lineWidth = oldLineWidth
		}

		// PARTICLES

		const pMass = 1, pRadius = 10, pColor = '#000', particles = []

		function Particle(x = 0, y = 0, force = [0, 0]) {			
			const particle = {
				id: Particle.id,
				x,
				y,
				force,
				addForce(forceX, forceY) {
					// this.force[0] += forcesArray.reduce((sum, [x, y]) => sum + x, 0)
					// this.force[1] += forcesArray.reduce((sum, [x, y]) => sum + y, 0)

					this.force[0] += forceX
					this.force[1] += forceY
				}
			}

			particles.push(particle)
			Particle.id++
		}

		Particle.id = 0

		// Particle(cHW - 100, cHH)
		// Particle(cHW + 100, cHH)
		// Particle(cHW + 31, cHH + 30)

		for(let i = 0; i < 50; i++) {
			Particle(Math.random() * cW * scale - pRadius, Math.random() * cH * scale - pRadius)
		}

		// RENDER

		ctx.strokeStyle = pColor

		let frameRate = 60, phisicSpeed = 5, displayVectors = 0
		// particles[0].addForce(0, 60)

		const getUpdate = setInterval(() => {
			
			requestAnimationFrame(() => {
				
				for(let p of particles) {

					// FORCES LIMIT

					function forceLimit() {
						if(p.force[0] > 2500) p.force[0] = 2500
						if(p.force[0] < -2500) p.force[0] = -2500
						if(p.force[1] > 2500) p.force[1] = 2500
						if(p.force[1] < -2500) p.force[1] = -2500
					}

					forceLimit()

					// MOVE

					for(const pN of particles) {
						if(pN !== p) {
							const m1 = pMass,
								  m2 = pMass,
								  r = Pt(p.x - pN.x, p.y - pN.y),
								  angle = angleBetweenVectors(1, 0, p.x - pN.x, p.y - pN.y)

							const force = 1e13 *Phis_G * ((m1 * m2) / r**2)
							

							p.addForce(...lineToAngle(force * -1, angle))
						}
					}

					// p.addForce(0, 10)

					function nextPos(direction) {

						switch (direction) {
							case 'x':
								return +(p.x + p.force[0] / pMass / frameRate).toFixed(2)
							case 'y':
								return +(p.y + p.force[1] / pMass / frameRate).toFixed(2)
						}
					}

					const stepX = nextPos('x'),
						  stepY = nextPos('y')
					
					// BORDER BOUNCE

					if(stepX >= cnvs.width - pRadius || 0 + pRadius >= stepX) p.force[0] *= -1
					if(stepY >= cnvs.height - pRadius || 0 + pRadius >= stepY) p.force[1] *= -1

					const pD = pRadius * 2

					for(const pN of particles) {
						if(pN !== p) {
							const r = +(Pt(stepX - pN.x, stepY - pN.y)).toFixed(2)

							if(r < pD) {
								let angle = angleBetweenVectors(1, 0, pN.x - p.x, pN.y - p.y) + 180,
									distance = pD - r

								p.x += lineToAngle(distance, angle)[0]
								p.y += lineToAngle(distance, angle)[1]
							}

							if(r <= pD) {
								let angle = angleBetweenVectors(...p.force, pN.x - p.x, pN.y - p.y),
									resForce = Pt(p.force[0], p.force[1])

								if(angle > 180) angle = 360 - angle
								if(angle > 90) angle = 180 - angle
								const resForceMultiplier = -((angle - 90) / 90)
								resForce *= resForceMultiplier**0.8

								// p.addForce(...lineToAngle(resForce * -1, 90))
								p.addForce(...lineToAngle(resForce * -1, angleBetweenVectors(1, 0, pN.x - p.x, pN.y - p.y)))
							}
						}
					}

					forceLimit()

					p.x = nextPos('x')
					p.y = nextPos('y')

					// DISPLAY

					ctx.clearRect(0, 0, cW * scale, cH * scale)

					for(const p of particles) {
						ctx.beginPath()
						ctx.arc(p.x, p.y, pRadius, 0, Math.PI * 2)
						ctx.stroke()
						displayVectors ? vector(p.x, p.y, p.force[0] / 5, p.force[1] / 5, 'red') : {}
					}
				}	
			})

		},  1000 / frameRate / phisicSpeed)
	</script>
</body>
</html>