<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Phisic particles</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			width: 100vw;
			height: 100vh;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		canvas {
			border: 1px solid #000;
		}
	</style>
</head>
<body>
	
	<canvas></canvas>

	<script>
		'use strict'

		const Phis_G = 6.67 * 1e-11

		const cnvs = document.querySelector('canvas'),
			  ctx = cnvs.getContext('2d'),
			  cW = innerWidth * 0.9,
			  cH = innerHeight * 0.9,
			  cHW = cW / 2,
			  cHH = cH / 2
			  
		cnvs.width = cW
		cnvs.height = cH

		cnvs.style.width = cW + 'px'
		cnvs.style.height = cH + 'px'

		// FUNCTIONS

		function mod(num) {
			if(num < 0) return num * -1
			return num
		}
		
		function toRad(deg) {
			return deg * Math.PI / 180
		}
		
		function toDeg(rad) {
			return rad * 180 / Math.PI
		}

		function Pt(catet1, catet2) {
			return Math.sqrt(catet1**2 + catet2**2)
		}
		
		function lineToAngle(distance, angle, x = 0, y = 0) {			
			return [
				+(Math.cos(toRad(angle)) * distance + x).toFixed(2), 
				+(Math.sin(toRad(angle)) * distance + y).toFixed(2)
			]
		}

		function preAngleBetweenVectors(a1, a2, b1, b2) {
			let angle = toDeg(Math.acos(((a1 * b1) + (a2 * b2)) / (Pt(a1, a2) * Pt(b1, b2))))
			if(b2 < 0) angle = 360 - angle
			return +angle.toFixed(2)
		}
		
		function angleBetweenVectors(a1, a2, b1, b2) {
			let deltaAngle = preAngleBetweenVectors(1, 0, a1, a2),
				deltaAngle2 = preAngleBetweenVectors(1, 0, b1, b2),
				angle = preAngleBetweenVectors(a1, a2, b1, b2)

			if(deltaAngle > deltaAngle2) angle = 360 - angle
			return angle
		}
		
		function vector(x, y, endX, endY, color = '#000', weight = 1) {
			const oldFillStyle = ctx.fillStyle,
				  oldStrokeStyle = ctx.strokeStyle,
				  oldLineWidth = ctx.LineWidth

			ctx.strokeStyle = color
			ctx.lineWidth = weight

			ctx.beginPath()
			ctx.moveTo(x, y)
			ctx.lineTo(x + endX, y + endY)
			ctx.stroke()

			ctx.beginPath()
			ctx.fillStyle = color		
			ctx.arc(x + endX, y + endY, weight + 1, 0, Math.PI * 2)
			ctx.fill()

			ctx.fillStyle = oldFillStyle
			ctx.strokeStyle = oldStrokeStyle
			ctx.lineWidth = oldLineWidth
		}

		// PARTICLES

		const pMass = 1, pRadius = 10, pColor = '#000', particles = []

		function Particle(x = 0, y = 0, force = [0, 0]) {			
			const particle = {
				id: Particle.id,
				x,
				y,
				force,
				addForce(forceX, forceY) {
					// this.force[0] += forcesArray.reduce((sum, [x, y]) => sum + x, 0)
					// this.force[1] += forcesArray.reduce((sum, [x, y]) => sum + y, 0)

					this.force[0] += forceX
					this.force[1] += forceY

					vector(this.x + this.force[0] / pMass / frameRate, this.y + this.force[1] / pMass / frameRate, forceX, forceY)
				}
			}

			particles.push(particle)
			Particle.id++
		}

		Particle.id = 0

		const forceDir = [0, 10]

		Particle(cHW + forceDir[0] * -3, cHH + forceDir[1] * -3, lineToAngle(0, 180))
		Particle(cHW, cHH, lineToAngle(0, 0))
		Particle(cHW + 30, cHH + 30, lineToAngle(0, 0))

		// RENDER

		ctx.strokeStyle = pColor

		const frameRate = 60, phisicSpeed = 0.5

		const getUpdate = setInterval(() => {
			
			requestAnimationFrame(() => {
				
				ctx.clearRect(0, 0, cW, cH)

				for(let p of particles) {

					if(p == particles[0]) {

						const p1 = particles[1]

						// FORCES LIMIT

						function forceLimit() {
							if(p.force[0] > 2500) p.force[0] = 2500
							if(p.force[0] < -2500) p.force[0] = -2500
							if(p.force[1] > 2500) p.force[1] = 2500
							if(p.force[1] < -2500) p.force[1] = -2500
						}

						forceLimit()

						// MOVE

						p.addForce(...forceDir)

						let stepX = +(p.x + p.force[0] / pMass / frameRate).toFixed(2),
							stepY = +(p.y + p.force[1] / pMass / frameRate).toFixed(2)
						
						// BORDER BOUNCE

						if(stepX >= cnvs.width - pRadius || 0 + pRadius >= stepX) p.force[0] *= -1
						if(stepY >= cnvs.height - pRadius || 0 + pRadius >= stepY) p.force[1] *= -1
						// else p.addForce(0, 10)

						let r = Pt(stepX - p1.x, stepY - p1.y), pD = pRadius * 2	

						if(r <= pD) {
							let angle = angleBetweenVectors(...forceDir, p1.x - p.x, p1.y - p.y)
							// if(p1.x - p.x > 0) angle = 360 - angle

							let resForce = Pt(p.force[0], p.force[1])

							let hAngle = angle

							if(hAngle > 180) hAngle = 360 - hAngle
							if(hAngle > 90) hAngle = 180 - hAngle
							else resForce *= -((hAngle - 90) / 90)

							p.addForce(...lineToAngle(resForce * -1, angle + angleBetweenVectors(1, 0, ...forceDir)))
						}

						forceLimit()

						stepX = +(p.x + p.force[0] / pMass / frameRate).toFixed(2),
						stepY = +(p.y + p.force[1] / pMass / frameRate).toFixed(2)

						p.x = stepX
						p.y = stepY

						vector(p.x, p.y, ...lineToAngle(10, angleBetweenVectors(1, 0, p1.x - p.x, p1.y - p.y)), 'blue')
					}

					// DISPLAY

					ctx.beginPath()
					ctx.arc(p.x, p.y, pRadius, 0, Math.PI * 2)
					ctx.stroke()
					vector(p.x, p.y, p.force[0] / 5, p.force[1] / 5, 'red')
				}	
			})

		},  1000 / frameRate / phisicSpeed)
	</script>
</body>
</html>