<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Phisic particles</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			width: 100vw;
			height: 100vh;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		canvas {
			border: 1px solid #000;
		}
	</style>
</head>
<body>
	
	<canvas></canvas>

	<script>
		'use strict'

		const Phis_G = 6.67 * 1e-11

		const cnvs = document.querySelector('canvas'),
			  ctx = cnvs.getContext('2d'),
			  cW = innerWidth * 0.9,
			  cH = innerHeight * 0.9,
			  cHW = cW / 2,
			  cHH = cH / 2
			  
		cnvs.width = cW
		cnvs.height = cH

		cnvs.style.width = cW + 'px'
		cnvs.style.height = cH + 'px'

		// FUNCTIONS

		function mod(num) {
			if(num < 0) return num * -1
			return num
		}
		
		function toRad(deg) {
			return deg * Math.PI / 180
		}
		
		function toDeg(rad) {
			return rad * 180 / Math.PI
		}

		function Pt(catet1, catet2) {
			return Math.sqrt(catet1**2 + catet2**2)
		}
		
		function lineToAngle(distance, angle, x = 0, y = 0) {			
			return [
				+(Math.cos(toRad(angle)) * distance + x).toFixed(2), 
				+(Math.sin(toRad(angle)) * distance + y).toFixed(2)
			]
		}

		function preAngleBetweenVectors(a1, a2, b1, b2) {
			let angle = toDeg(Math.acos(((a1 * b1) + (a2 * b2)) / (Pt(a1, a2) * Pt(b1, b2))))
			if(b2 < 0) angle = 360 - angle
			return +angle.toFixed(2)
		}
		
		function angleBetweenVectors(a1, a2, b1, b2) {
			let deltaAngle = preAngleBetweenVectors(1, 0, a1, a2),
				deltaAngle2 = preAngleBetweenVectors(1, 0, b1, b2),
				angle = preAngleBetweenVectors(a1, a2, b1, b2)

			if(deltaAngle > deltaAngle2) angle = 360 - angle
			return angle
		}
		
		function vector(x, y, endX, endY, color = '#000', Width = 1) {
			const oldFillStyle = ctx.fillStyle,
				  oldStrokeStyle = ctx.strokeStyle,
				  oldLineWidth = ctx.LineWidth

			ctx.strokeStyle = color
			ctx.lineWidth = Width

			ctx.beginPath()
			ctx.moveTo(x, y)
			ctx.lineTo(x + endX, y + endY)
			ctx.stroke()

			ctx.beginPath()
			ctx.fillStyle = color		
			ctx.arc(x + endX, y + endY, Width + 1, 0, Math.PI * 2)
			ctx.fill()

			ctx.fillStyle = oldFillStyle
			ctx.strokeStyle = oldStrokeStyle
			ctx.lineWidth = oldLineWidth
		}

		function circum(x, y, radius, color = '#000', Width = 1) {
			const oldStrokeStyle = ctx.strokeStyle,
				  oldLineWidth = ctx.LineWidth

			ctx.beginPath()
			ctx.strokeStyle = color
			ctx.lineWidth = Width
			ctx.arc(x, y, radius, 0, Math.PI * 2)
			ctx.stroke()

			ctx.strokeStyle = oldStrokeStyle
			ctx.lineWidth = oldLineWidth
		}

		// PARTICLES

		const pMass = 1, pRadius = 10, pColor = '#000', particles = []

		function Particle(x = 0, y = 0, force = [0, 0]) {			
			const particle = {
				id: Particle.id,
				x,
				y,
				force,
				addForce(forceX, forceY) {
					// this.force[0] += forcesArray.reduce((sum, [x, y]) => sum + x, 0)
					// this.force[1] += forcesArray.reduce((sum, [x, y]) => sum + y, 0)

					this.force[0] += forceX
					this.force[1] += forceY

					vector(this.x + this.force[0] / pMass / frameRate, this.y + this.force[1] / pMass / frameRate, forceX, forceY)
				}
			}

			particles.push(particle)
			Particle.id++
		}

		Particle.id = 0

		const forceDir = [0, 10]

		Particle(cHW + forceDir[0] * -3, cHH + forceDir[1] - 200, lineToAngle(0, 180))

		const obstacles = [
			[cHW, cHH + 150, 200],
			// [cHW, cHH, pRadius],
			// [cHW + 20, cHH + 20, pRadius],
			// [cHW + 30, cHH, pRadius],
			// [cHW + 10, cHH + 20, pRadius],
		]

		// RENDER

		ctx.strokeStyle = pColor

		let frameRate = 60, phisicSpeed = 0.5
		particles[0].addForce(0, 5000)

		const getUpdate = setInterval(() => {
			
			requestAnimationFrame(() => {
				
				ctx.clearRect(0, 0, cW, cH)

				for(let p of particles) {

					if(p == particles[0]) {

						// FORCES LIMIT

						function forceLimit() {
							if(p.force[0] > 2500) p.force[0] = 2500
							if(p.force[0] < -2500) p.force[0] = -2500
							if(p.force[1] > 2500) p.force[1] = 2500
							if(p.force[1] < -2500) p.force[1] = -2500
						}

						forceLimit()

						// MOVE

						p.addForce(...forceDir)

						function nextPos(direction) {

							switch (direction) {
								case 'x':
									return +(p.x + p.force[0] / pMass / frameRate).toFixed(2)
								case 'y':
									return +(p.y + p.force[1] / pMass / frameRate).toFixed(2)
							}
						}

						const stepX = nextPos('x'),
							  stepY = nextPos('y')
						
						// BORDER BOUNCE

						if(stepX >= cnvs.width - pRadius || 0 + pRadius >= stepX) p.force[0] *= -1
						if(stepY >= cnvs.height - pRadius || 0 + pRadius >= stepY) p.force[1] *= -1
						// else p.addForce(0, 10)

						const pD = pRadius * 2

						for(const obs of obstacles) {
							const r = +(Pt(stepX - obs[0], stepY - obs[1])).toFixed(2)

							if(r < obs[2] + pRadius) {
								let angle = angleBetweenVectors(1, 0, obs[0] - p.x, obs[1] - p.y) + 180,
									distance = obs[2] + pRadius - r

								p.x += lineToAngle(distance, angle)[0]
								p.y += lineToAngle(distance, angle)[1]
							}

							if(r <= obs[2] + pRadius) {
								let angle = angleBetweenVectors(...p.force, obs[0] - p.x, obs[1] - p.y),
									resForce = Pt(p.force[0], p.force[1])
	
								if(angle > 180) angle = 360 - angle
								if(angle > 90) angle = 180 - angle
								const resForceMultiplier = -((angle - 90) / 90)
								resForce *= resForceMultiplier**0.8
	
								// p.addForce(...lineToAngle(resForce * -1, 90))
								p.addForce(...lineToAngle(resForce * -1, angleBetweenVectors(1, 0, obs[0] - p.x, obs[1] - p.y)))
							}
						}


						forceLimit()

						p.x = nextPos('x')
						p.y = nextPos('y')
					}

					// DISPLAY

					ctx.beginPath()
					ctx.arc(p.x, p.y, pRadius, 0, Math.PI * 2)
					ctx.stroke()
					vector(p.x, p.y, p.force[0] / 5, p.force[1] / 5, 'red')

					for(const obs of obstacles) {
						circum(...obs)
					}
				}	
			})

		},  1000 / frameRate / phisicSpeed)
	</script>
</body>
</html>